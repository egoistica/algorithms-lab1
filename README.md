# Бенчмарк функций f(v)

Задача: для каждого n от 1 до 2000 сгенерировать случайный неотрицательный вектор `v` и измерить среднее машинное время выполнения:
- `f(v)=1` (константа)
- `f(v)=∑ v_k` (сумма элементов)
- `f(v)=∏ v_k` (произведение элементов)

Генерация вектора исключена из замера времени — измеряется только вычисление функции на уже готовом векторе.

## Вариант на C#/.NET (рекомендуется)

Проект: `CsBench` (консольное приложение .NET 8, графики через ScottPlot)

### Требования
- Установлен .NET SDK 8.0+ (`dotnet --version`)

### Установка и запуск (Windows PowerShell)

```powershell
cd CsBench
 dotnet restore
 dotnet run -c Release -- --max-n 2000 --runs 5 --seed 42 --csv results.csv --png results.png
```

После выполнения появятся файлы `results.csv` и `results.png` в каталоге `CsBench`.

Параметры:
- `--max-n` — максимальное n (по умолчанию 2000)
- `--runs` — число повторов на каждое n (по умолчанию 5)
- `--seed` — сид генератора случайных чисел (по умолчанию 42)
- `--csv` — путь к CSV
- `--png` — путь к PNG

## Вариант на Python (альтернативно)

Если нужен Python-вариант, в корне есть `benchmark.py`.

### Установка зависимостей (Windows PowerShell)

```powershell
py -m venv .venv
 . .venv\Scripts\Activate.ps1
 pip install -r requirements.txt
```

### Запуск (Python)

```powershell
python benchmark.py --max-n 2000 --runs 5 --seed 42 --png results.png --csv results.csv
```

## Теоретическая сложность
- `f(v)=1` — O(1)
- `f(v)=∑ v_k` — O(n)
- `f(v)=∏ v_k` — O(n)

Ожидание: кривые для суммы и произведения растут линейно с `n`, кривая для константы — практически горизонтальная. Эмпирическая проверка отражена в `results.png`.
